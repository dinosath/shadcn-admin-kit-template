{% if protocol == 'rest' -%}
import simpleRestProvider from 'ra-data-simple-rest';
import type { DataProvider, CreateParams, UpdateParams, RaRecord } from 'ra-core';
{% if authentication != 'none' -%}
import { fetchUtils } from 'ra-core';
import { getAuthToken } from '@/lib/authProvider';

const httpClient = (url: string, options: fetchUtils.Options = {}) => {
    const token = getAuthToken();
    const headers = new Headers(options.headers || {});
    if (token) {
        headers.set('Authorization', `Bearer ${token}`);
    }
    return fetchUtils.fetchJson(url, { ...options, headers });
};

const baseDataProvider = simpleRestProvider('/api', httpClient);
{% else -%}
const baseDataProvider = simpleRestProvider('/api');
{% endif %}

/**
 * Relation fields configuration per resource.
 * Maps resource names to their relation field names.
 * These fields will be transformed from { field: id } to { field: { id: id } }
 * for create/update operations to match backend expectations.
 */
const relationFields: Record<string, string[]> = {
{% for entity_name, entity in entities | items | selectattr("1.attributes") -%}
{% set ns = namespace(relations=[]) -%}
{% for name, property in entity.attributes | items -%}
{% if property.relation == 'manyToOne' or property.relation == 'oneToOne' -%}
{% set ns.relations = ns.relations + [name | snake_case] -%}
{% endif -%}
{% endfor -%}
{% if ns.relations | length > 0 -%}
    '{{ entity_name | plural | snake_case }}': [{% for rel in ns.relations %}'{{ rel }}'{% if not loop.last %}, {% endif %}{% endfor %}],
{% endif -%}
{% endfor %}
};

/**
 * Transform data for create/update operations.
 * Converts relation fields from { field: id } to { field: { id: id } }
 */
const transformForMutation = <T extends Record<string, unknown>>(resource: string, data: T): T => {
    const fields = relationFields[resource];
    if (!fields || fields.length === 0) {
        return data;
    }

    const transformed = { ...data } as T;
    for (const field of fields) {
        const value = transformed[field];
        // If value is a primitive (number or string), wrap it in { id: value }
        if (value !== null && value !== undefined && typeof value !== 'object') {
            (transformed as Record<string, unknown>)[field] = { id: value };
        }
        // If value is already an object with id, keep it as is
        // If value is null/undefined, keep it as is
    }
    return transformed;
};

/**
 * Transform data from API response.
 * Converts relation fields from { field: { id: id, ... } } to { field: id }
 * for react-admin ReferenceInput/ReferenceField compatibility.
 */
const transformFromResponse = <T extends RaRecord>(resource: string, data: T): T => {
    const fields = relationFields[resource];
    if (!fields || fields.length === 0) {
        return data;
    }

    const transformed = { ...data } as T;
    for (const field of fields) {
        const value = (transformed as Record<string, unknown>)[field];
        // If value is an object with id, extract just the id
        if (value !== null && value !== undefined && typeof value === 'object' && 'id' in (value as object)) {
            (transformed as Record<string, unknown>)[field] = (value as { id: unknown }).id;
        }
    }
    return transformed;
};

/**
 * Data provider wrapper that handles relation field transformations.
 */
export const dataProvider: DataProvider = {
    ...baseDataProvider,

    getList: async (resource, params) => {
        const result = await baseDataProvider.getList(resource, params);
        return {
            ...result,
            data: result.data.map((item) => transformFromResponse(resource, item)),
        };
    },

    getOne: async (resource, params) => {
        const result = await baseDataProvider.getOne(resource, params);
        return {
            ...result,
            data: transformFromResponse(resource, result.data),
        };
    },

    getMany: async (resource, params) => {
        const result = await baseDataProvider.getMany(resource, params);
        return {
            ...result,
            data: result.data.map((item) => transformFromResponse(resource, item)),
        };
    },

    getManyReference: async (resource, params) => {
        const result = await baseDataProvider.getManyReference(resource, params);
        return {
            ...result,
            data: result.data.map((item) => transformFromResponse(resource, item)),
        };
    },

    create: async (resource, params: CreateParams) => {
        const transformedParams = {
            ...params,
            data: transformForMutation(resource, params.data as Record<string, unknown>),
        };
        const result = await baseDataProvider.create(resource, transformedParams);
        return {
            ...result,
            data: transformFromResponse(resource, result.data),
        };
    },

    update: async (resource, params: UpdateParams) => {
        const transformedParams = {
            ...params,
            data: transformForMutation(resource, params.data as Record<string, unknown>),
        };
        const result = await baseDataProvider.update(resource, transformedParams);
        return {
            ...result,
            data: transformFromResponse(resource, result.data),
        };
    },

    // delete and deleteMany don't need transformation
    delete: baseDataProvider.delete,
    deleteMany: baseDataProvider.deleteMany,
    updateMany: baseDataProvider.updateMany,
};
{% endif %}
